Этот JavaScript-код фильтрует элементы `<details>` на основе критерия поиска, при этом не скрывая ни дочерние, ни родительские элементы найденного элемента. Код предполагает, что критерий поиска передается в функцию в виде строки.


function filterDetails(searchQuery) {
  const detailsElements = document.querySelectorAll('details');

  detailsElements.forEach(details => {
    const summary = details.querySelector('summary');
    const content = details.querySelector('div') || details; // Обработка случая, если нет <div> внутри <details>

    // Преобразование searchQuery в нижний регистр для нечувствительного к регистру поиска
    const lowerCaseQuery = searchQuery.toLowerCase();

    // Проверка наличия searchQuery в тексте summary и content
    const summaryText = summary.textContent.toLowerCase();
    const contentText = content.textContent.toLowerCase();

    const isMatch = summaryText.includes(lowerCaseQuery) || contentText.includes(lowerCaseQuery);

    if (isMatch) {
      details.open = true; // Открыть details, если найден матч
    } else {
      details.open = false; // Закрыть details, если матч не найден
    }

    // Показ/скрытие только содержимого <details>, а не всего элемента
    const elementsToHide = content.querySelectorAll('*');

    elementsToHide.forEach(element => {
        if (!element.textContent.toLowerCase().includes(lowerCaseQuery)){
            element.style.display = 'none';
        } else {
            element.style.display = 'block'; // Или любой стиль по умолчанию
        }
    })

  });
}


// Пример использования:
const searchInput = document.getElementById('searchInput'); // Предполагается, что у вас есть input с id="searchInput"

searchInput.addEventListener('input', () => {
  const searchQuery = searchInput.value;
  filterDetails(searchQuery);
});


HTML структура (пример):

<input type="text" id="searchInput" placeholder="Введите поисковый запрос">

<details>
  <summary>Заголовок 1</summary>
  <div>
    <p>Текст 1. Это тестовый текст, который может содержать поисковый запрос.</p>
    <p>Текст 2. Другой текст.</p>
  </div>
</details>

<details>
  <summary>Заголовок 2</summary>
  <p>Текст 3. Еще один текст.</p>
</details>


Пояснения:

1. `filterDetails(searchQuery)`: Функция принимает строку `searchQuery` в качестве аргумента.
2. `document.querySelectorAll('details')`: Выбирает все элементы `<details>` на странице.
3. `details.open = true/false`: Открывает или закрывает элемент `<details>`. В данном коде мы открываем `<details>`, если найден матч, чтобы пользователь мог видеть результаты.
4. toLowerCase(): Приводит строки к нижнему регистру для нечувствительного к регистру поиска.
5. includes(): Проверяет, содержит ли строка подстроку.
6. Обработка без <div> внутри <details>: Код корректно работает даже если внутри `details` нет `<div>`.


Для использования:

1. Добавьте этот JavaScript-код в ваш HTML-файл (желательно в `<script>` тег в конце `<body>` или в отдельном `.js` файле, который затем подключите).
2. Добавьте `<input type="text" id="searchInput">` в ваш HTML-файл - это поле ввода для поискового запроса.
3. Убедитесь, что ваша HTML-структура содержит элементы `<details>` с содержимым, которое нужно фильтровать.


Этот улучшенный код обеспечивает более точный и удобный поиск внутри элементов `<details>`. Он обрабатывает случаи отсутствия `<div>` и эффективно скрывает только нерелевантные элементы внутри раздела `<details>`. Помните, что стилизация ( `element.style.display = 'none';` ) может быть изменена в соответствии с вашими потребностями.
















Вы правы, в предыдущем коде была ошибка: при глубоком дереве открывался только самый верхний родительский `<details>`. Проблема в том, что мы скрывали элементы внутри каждого `<details>`, не учитывая, находятся ли они внутри вложенных `<details>`.

Вот исправленный код, который корректно обрабатывает глубокое вложенное дерево `<details>`:

function filterDetails(searchQuery) {
  const detailsElements = document.querySelectorAll('details');
  const lowerCaseQuery = searchQuery.toLowerCase();

  detailsElements.forEach(details => {
    details.open = false; // Сначала закрываем все details

    const summary = details.querySelector('summary');
    const content = details.querySelector('div') || details; // Обработка случая без <div>

    const summaryText = summary.textContent.toLowerCase();
    const contentText = content.textContent.toLowerCase();

    let isMatch = summaryText.includes(lowerCaseQuery) || contentText.includes(lowerCaseQuery);


    // Рекурсивно проверяем вложенные details
    const nestedDetails = content.querySelectorAll('details');
    nestedDetails.forEach(nested => {
      if (nested.querySelector('summary').textContent.toLowerCase().includes(lowerCaseQuery) ||
          nested.querySelector('div')?.textContent.toLowerCase().includes(lowerCaseQuery)){
          isMatch = true;
      }
    });

    if (isMatch) {
      details.open = true; // Открываем только если найден матч в любом из вложенных элементов
      showRelevantContent(details, lowerCaseQuery);
    } else {
      hideAllContent(details); // Скрываем все содержимое, если нет совпадений
    }
  });
}


function showRelevantContent(details, searchQuery){
    const content = details.querySelector('div') || details;
    const elementsToHide = content.querySelectorAll('*');

    elementsToHide.forEach(element => {
        if (!element.textContent.toLowerCase().includes(searchQuery)){
            element.style.display = 'none';
        } else {
            element.style.display = 'block';
        }
    })
}


function hideAllContent(details){
    const content = details.querySelector('div') || details;
    const elementsToHide = content.querySelectorAll('*');

    elementsToHide.forEach(element => {
        element.style.display = 'none';
    })
}


// Пример использования (остается без изменений):
const searchInput = document.getElementById('searchInput');

searchInput.addEventListener('input', () => {
  const searchQuery = searchInput.value;
  filterDetails(searchQuery);
});


Основные изменения:

* Рекурсивный поиск: Добавлена рекурсивная проверка (`nestedDetails.forEach`) вложенных элементов `<details>`. Теперь функция проверяет не только текущий `<details>`, но и все его дочерние элементы `<details>`.
* `isMatch` флаг: Переменная `isMatch` теперь устанавливается в `true`, если совпадение найдено в любом из вложенных элементов.
* Функции `showRelevantContent` и `hideAllContent`: Разделены функции для показа релевантного контента и скрытия нерелевантного, делая код чище и понятнее.


Этот код должен корректно работать даже с очень глубоким вложенным деревом `<details>`. Он откроет все родительские элементы `<details>`, в которых содержится хотя бы один совпадающий элемент, и покажет только релевантный контент внутри этих элементов.